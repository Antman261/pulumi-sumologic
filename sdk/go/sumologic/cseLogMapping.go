// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package sumologic

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a Sumologic CSE Log Mapping.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-sumologic/sdk/go/sumologic"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		_, err := sumologic.NewCseLogMapping(ctx, "logMapping", &sumologic.CseLogMappingArgs{
// 			Enabled: pulumi.Bool(true),
// 			Fields: sumologic.CseLogMappingFieldArray{
// 				&sumologic.CseLogMappingFieldArgs{
// 					AlternateValues: pulumi.StringArray{
// 						pulumi.String("altValue"),
// 					},
// 					CaseInsensitive: pulumi.Bool(false),
// 					DefaultValue:    pulumi.String(""),
// 					FieldJoins: pulumi.StringArray{
// 						pulumi.String("and"),
// 					},
// 					Format: pulumi.String("JSON"),
// 					FormatParameters: pulumi.StringArray{
// 						pulumi.String("param"),
// 					},
// 					JoinDelimiter: pulumi.String(""),
// 					Lookups: sumologic.CseLogMappingFieldLookupArray{
// 						&sumologic.CseLogMappingFieldLookupArgs{
// 							Key:   pulumi.String("tunnel-up"),
// 							Value: pulumi.String("true"),
// 						},
// 					},
// 					Name: pulumi.String("action"),
// 					SkippedValues: pulumi.StringArray{
// 						pulumi.String("-"),
// 					},
// 					SplitDelimiter: pulumi.String(","),
// 					SplitIndex:     pulumi.String("index"),
// 					TimeZone:       pulumi.String("UTC"),
// 					Value:          pulumi.String("action"),
// 					ValueType:      pulumi.String("constant"),
// 				},
// 			},
// 			ProductGuid:     pulumi.String("003d35b3-3ba8-4e93-8776-e5810b4e243e"),
// 			RecordType:      pulumi.String("Audit"),
// 			RelatesEntities: pulumi.Bool(true),
// 			SkippedValues: pulumi.StringArray{
// 				pulumi.String("skipped"),
// 			},
// 			StructuredInputs: sumologic.CseLogMappingStructuredInputArray{
// 				&sumologic.CseLogMappingStructuredInputArgs{
// 					EventIdPattern: pulumi.String("vpn"),
// 					LogFormat:      pulumi.String("JSON"),
// 					Product:        pulumi.String("fortinate"),
// 					Vendor:         pulumi.String("fortinate"),
// 				},
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
// ## Argument reference
//
// The following arguments are supported:
//
// - `name` - (Required) The name of the log mapping.
// - `parentId` - (Optional) The id of the parent log mapping.
// - `productGuid` - (Required) Product GUID.
// - `recordType` - (Required) The record type to be created. (possible values: Audit, AuditChange, AuditFile, AuditResourceAccess, Authentication, AuthenticationPrivilegeEscalation, Canary, Email, Endpoint, EndpointModuleLoad, EndpointProcess, Network, NetworkDHCP, NetworkDNS, NetworkFlow, NetworkHTTP, NetworkProxy, Notification, NotificationVulnerability)
// - `enabled` - (Required) Enabled flag.
// - `relatesEntities` - (Optional) Set to true to relate entities.
// - `skippedValues` - (Optional) List of skipped values.
// - `fields` - (Required) List of fields for the new log mapping. See fieldSchema for details.
// - `structuredInputs` - (Optional, omit if unstructuredFields is defined) List of structured inputs for the new log mapping. See structuredInputSchema for details.
// - `unstructuredFields` - (Optional, omit if structuredInputs is defined) Unstructured fields for the new log mapping. See unstructuredFieldSchema for details.
//
// ### Schema for `field`
// - `name` - (Required) Name of the field.
// - `value` - (Optional) Value of the field.
// - `valueType` - (Optional) The value type.
// - `skippedValues` - (Optional) List of skipped values.
// - `defaultValue` - (Optional) Default value of the field.
// - `format` - (Optional) Format of the field. (JSON, Windows, Syslog, CEF, LEEF )
// - `caseInsensitive` - (Optional) Case insensitive flag.
// - `alternateValues` - (Optional) List of alternate values.
// - `timeZone` - (Optional) Time zone.
// - `splitDelimiter` - (Optional) Split delimiter to be used. (some example: ",", "-", "|")
// - `fieldJoin` - (Optional) List of field join values.
// - `joinDelimiter` - (Optional) Join delimiter.
// - `formatParameters` - (Optional) List of format parameters.
// - `lookup` - (Optional) List of lookup key value pair for field. See lookupSchema for details.
//
// ### Schema for `lookup`
// - `key` - (Required) Lookup key.
// - `value` - (Required) Lookup value.
//
// ### Schema for `structuredInput`
// - `eventIdPattern` - (Required) Event id pattern.
// - `logFormat` - (Required) Log format. (JSON, Windows, Syslog, CEF, LEEF )
// - `product` - (Required) Product name.
// - `vendor` - (Required) Vendor name.
//
// ### Schema for `unstructuredField`
// - `patternNames` - (Required) List of grok pattern names.
//
// The following attributes are exported:
//
// - `id` - The internal ID of the log mapping.
//
// ## Import
//
// Log Mapping can be imported using the field id, e.g.hcl
//
// ```sh
//  $ pulumi import sumologic:index/cseLogMapping:CseLogMapping log_mapping id
// ```
type CseLogMapping struct {
	pulumi.CustomResourceState

	Enabled            pulumi.BoolOutput                        `pulumi:"enabled"`
	Fields             CseLogMappingFieldArrayOutput            `pulumi:"fields"`
	Name               pulumi.StringOutput                      `pulumi:"name"`
	ParentId           pulumi.StringPtrOutput                   `pulumi:"parentId"`
	ProductGuid        pulumi.StringOutput                      `pulumi:"productGuid"`
	RecordType         pulumi.StringOutput                      `pulumi:"recordType"`
	RelatesEntities    pulumi.BoolPtrOutput                     `pulumi:"relatesEntities"`
	SkippedValues      pulumi.StringArrayOutput                 `pulumi:"skippedValues"`
	StructuredInputs   CseLogMappingStructuredInputArrayOutput  `pulumi:"structuredInputs"`
	UnstructuredFields CseLogMappingUnstructuredFieldsPtrOutput `pulumi:"unstructuredFields"`
}

// NewCseLogMapping registers a new resource with the given unique name, arguments, and options.
func NewCseLogMapping(ctx *pulumi.Context,
	name string, args *CseLogMappingArgs, opts ...pulumi.ResourceOption) (*CseLogMapping, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Enabled == nil {
		return nil, errors.New("invalid value for required argument 'Enabled'")
	}
	if args.Fields == nil {
		return nil, errors.New("invalid value for required argument 'Fields'")
	}
	if args.ProductGuid == nil {
		return nil, errors.New("invalid value for required argument 'ProductGuid'")
	}
	if args.RecordType == nil {
		return nil, errors.New("invalid value for required argument 'RecordType'")
	}
	var resource CseLogMapping
	err := ctx.RegisterResource("sumologic:index/cseLogMapping:CseLogMapping", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetCseLogMapping gets an existing CseLogMapping resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetCseLogMapping(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *CseLogMappingState, opts ...pulumi.ResourceOption) (*CseLogMapping, error) {
	var resource CseLogMapping
	err := ctx.ReadResource("sumologic:index/cseLogMapping:CseLogMapping", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering CseLogMapping resources.
type cseLogMappingState struct {
	Enabled            *bool                            `pulumi:"enabled"`
	Fields             []CseLogMappingField             `pulumi:"fields"`
	Name               *string                          `pulumi:"name"`
	ParentId           *string                          `pulumi:"parentId"`
	ProductGuid        *string                          `pulumi:"productGuid"`
	RecordType         *string                          `pulumi:"recordType"`
	RelatesEntities    *bool                            `pulumi:"relatesEntities"`
	SkippedValues      []string                         `pulumi:"skippedValues"`
	StructuredInputs   []CseLogMappingStructuredInput   `pulumi:"structuredInputs"`
	UnstructuredFields *CseLogMappingUnstructuredFields `pulumi:"unstructuredFields"`
}

type CseLogMappingState struct {
	Enabled            pulumi.BoolPtrInput
	Fields             CseLogMappingFieldArrayInput
	Name               pulumi.StringPtrInput
	ParentId           pulumi.StringPtrInput
	ProductGuid        pulumi.StringPtrInput
	RecordType         pulumi.StringPtrInput
	RelatesEntities    pulumi.BoolPtrInput
	SkippedValues      pulumi.StringArrayInput
	StructuredInputs   CseLogMappingStructuredInputArrayInput
	UnstructuredFields CseLogMappingUnstructuredFieldsPtrInput
}

func (CseLogMappingState) ElementType() reflect.Type {
	return reflect.TypeOf((*cseLogMappingState)(nil)).Elem()
}

type cseLogMappingArgs struct {
	Enabled            bool                             `pulumi:"enabled"`
	Fields             []CseLogMappingField             `pulumi:"fields"`
	Name               *string                          `pulumi:"name"`
	ParentId           *string                          `pulumi:"parentId"`
	ProductGuid        string                           `pulumi:"productGuid"`
	RecordType         string                           `pulumi:"recordType"`
	RelatesEntities    *bool                            `pulumi:"relatesEntities"`
	SkippedValues      []string                         `pulumi:"skippedValues"`
	StructuredInputs   []CseLogMappingStructuredInput   `pulumi:"structuredInputs"`
	UnstructuredFields *CseLogMappingUnstructuredFields `pulumi:"unstructuredFields"`
}

// The set of arguments for constructing a CseLogMapping resource.
type CseLogMappingArgs struct {
	Enabled            pulumi.BoolInput
	Fields             CseLogMappingFieldArrayInput
	Name               pulumi.StringPtrInput
	ParentId           pulumi.StringPtrInput
	ProductGuid        pulumi.StringInput
	RecordType         pulumi.StringInput
	RelatesEntities    pulumi.BoolPtrInput
	SkippedValues      pulumi.StringArrayInput
	StructuredInputs   CseLogMappingStructuredInputArrayInput
	UnstructuredFields CseLogMappingUnstructuredFieldsPtrInput
}

func (CseLogMappingArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*cseLogMappingArgs)(nil)).Elem()
}

type CseLogMappingInput interface {
	pulumi.Input

	ToCseLogMappingOutput() CseLogMappingOutput
	ToCseLogMappingOutputWithContext(ctx context.Context) CseLogMappingOutput
}

func (*CseLogMapping) ElementType() reflect.Type {
	return reflect.TypeOf((*CseLogMapping)(nil))
}

func (i *CseLogMapping) ToCseLogMappingOutput() CseLogMappingOutput {
	return i.ToCseLogMappingOutputWithContext(context.Background())
}

func (i *CseLogMapping) ToCseLogMappingOutputWithContext(ctx context.Context) CseLogMappingOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CseLogMappingOutput)
}

func (i *CseLogMapping) ToCseLogMappingPtrOutput() CseLogMappingPtrOutput {
	return i.ToCseLogMappingPtrOutputWithContext(context.Background())
}

func (i *CseLogMapping) ToCseLogMappingPtrOutputWithContext(ctx context.Context) CseLogMappingPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CseLogMappingPtrOutput)
}

type CseLogMappingPtrInput interface {
	pulumi.Input

	ToCseLogMappingPtrOutput() CseLogMappingPtrOutput
	ToCseLogMappingPtrOutputWithContext(ctx context.Context) CseLogMappingPtrOutput
}

type cseLogMappingPtrType CseLogMappingArgs

func (*cseLogMappingPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**CseLogMapping)(nil))
}

func (i *cseLogMappingPtrType) ToCseLogMappingPtrOutput() CseLogMappingPtrOutput {
	return i.ToCseLogMappingPtrOutputWithContext(context.Background())
}

func (i *cseLogMappingPtrType) ToCseLogMappingPtrOutputWithContext(ctx context.Context) CseLogMappingPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CseLogMappingPtrOutput)
}

// CseLogMappingArrayInput is an input type that accepts CseLogMappingArray and CseLogMappingArrayOutput values.
// You can construct a concrete instance of `CseLogMappingArrayInput` via:
//
//          CseLogMappingArray{ CseLogMappingArgs{...} }
type CseLogMappingArrayInput interface {
	pulumi.Input

	ToCseLogMappingArrayOutput() CseLogMappingArrayOutput
	ToCseLogMappingArrayOutputWithContext(context.Context) CseLogMappingArrayOutput
}

type CseLogMappingArray []CseLogMappingInput

func (CseLogMappingArray) ElementType() reflect.Type {
	return reflect.TypeOf(([]*CseLogMapping)(nil))
}

func (i CseLogMappingArray) ToCseLogMappingArrayOutput() CseLogMappingArrayOutput {
	return i.ToCseLogMappingArrayOutputWithContext(context.Background())
}

func (i CseLogMappingArray) ToCseLogMappingArrayOutputWithContext(ctx context.Context) CseLogMappingArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CseLogMappingArrayOutput)
}

// CseLogMappingMapInput is an input type that accepts CseLogMappingMap and CseLogMappingMapOutput values.
// You can construct a concrete instance of `CseLogMappingMapInput` via:
//
//          CseLogMappingMap{ "key": CseLogMappingArgs{...} }
type CseLogMappingMapInput interface {
	pulumi.Input

	ToCseLogMappingMapOutput() CseLogMappingMapOutput
	ToCseLogMappingMapOutputWithContext(context.Context) CseLogMappingMapOutput
}

type CseLogMappingMap map[string]CseLogMappingInput

func (CseLogMappingMap) ElementType() reflect.Type {
	return reflect.TypeOf((map[string]*CseLogMapping)(nil))
}

func (i CseLogMappingMap) ToCseLogMappingMapOutput() CseLogMappingMapOutput {
	return i.ToCseLogMappingMapOutputWithContext(context.Background())
}

func (i CseLogMappingMap) ToCseLogMappingMapOutputWithContext(ctx context.Context) CseLogMappingMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CseLogMappingMapOutput)
}

type CseLogMappingOutput struct {
	*pulumi.OutputState
}

func (CseLogMappingOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*CseLogMapping)(nil))
}

func (o CseLogMappingOutput) ToCseLogMappingOutput() CseLogMappingOutput {
	return o
}

func (o CseLogMappingOutput) ToCseLogMappingOutputWithContext(ctx context.Context) CseLogMappingOutput {
	return o
}

func (o CseLogMappingOutput) ToCseLogMappingPtrOutput() CseLogMappingPtrOutput {
	return o.ToCseLogMappingPtrOutputWithContext(context.Background())
}

func (o CseLogMappingOutput) ToCseLogMappingPtrOutputWithContext(ctx context.Context) CseLogMappingPtrOutput {
	return o.ApplyT(func(v CseLogMapping) *CseLogMapping {
		return &v
	}).(CseLogMappingPtrOutput)
}

type CseLogMappingPtrOutput struct {
	*pulumi.OutputState
}

func (CseLogMappingPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CseLogMapping)(nil))
}

func (o CseLogMappingPtrOutput) ToCseLogMappingPtrOutput() CseLogMappingPtrOutput {
	return o
}

func (o CseLogMappingPtrOutput) ToCseLogMappingPtrOutputWithContext(ctx context.Context) CseLogMappingPtrOutput {
	return o
}

type CseLogMappingArrayOutput struct{ *pulumi.OutputState }

func (CseLogMappingArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]CseLogMapping)(nil))
}

func (o CseLogMappingArrayOutput) ToCseLogMappingArrayOutput() CseLogMappingArrayOutput {
	return o
}

func (o CseLogMappingArrayOutput) ToCseLogMappingArrayOutputWithContext(ctx context.Context) CseLogMappingArrayOutput {
	return o
}

func (o CseLogMappingArrayOutput) Index(i pulumi.IntInput) CseLogMappingOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) CseLogMapping {
		return vs[0].([]CseLogMapping)[vs[1].(int)]
	}).(CseLogMappingOutput)
}

type CseLogMappingMapOutput struct{ *pulumi.OutputState }

func (CseLogMappingMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]CseLogMapping)(nil))
}

func (o CseLogMappingMapOutput) ToCseLogMappingMapOutput() CseLogMappingMapOutput {
	return o
}

func (o CseLogMappingMapOutput) ToCseLogMappingMapOutputWithContext(ctx context.Context) CseLogMappingMapOutput {
	return o
}

func (o CseLogMappingMapOutput) MapIndex(k pulumi.StringInput) CseLogMappingOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) CseLogMapping {
		return vs[0].(map[string]CseLogMapping)[vs[1].(string)]
	}).(CseLogMappingOutput)
}

func init() {
	pulumi.RegisterOutputType(CseLogMappingOutput{})
	pulumi.RegisterOutputType(CseLogMappingPtrOutput{})
	pulumi.RegisterOutputType(CseLogMappingArrayOutput{})
	pulumi.RegisterOutputType(CseLogMappingMapOutput{})
}
