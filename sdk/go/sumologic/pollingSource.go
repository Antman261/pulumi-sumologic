// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package sumologic

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// !> **WARNING:** This data source is deprecated and will be removed in the next major version.
//
// Provides a Sumologic Polling source. This source is used to import data from various AWS products, eg. AWS S3 buckets, Cloudwatch Metrics etc.
//
// __IMPORTANT:__ The AWS credentials are stored in plain-text in the state. This is a potential security issue.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-sumologic/sdk/go/sumologic"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		tagfilters := []map[string]interface{}{
// 			map[string]interface{}{
// 				"type":      "TagFilters",
// 				"namespace": "All",
// 				"tags": []string{
// 					"k3=v3",
// 				},
// 			},
// 			map[string]interface{}{
// 				"type":      "TagFilters",
// 				"namespace": "AWS/Route53",
// 				"tags": []string{
// 					"k1=v1",
// 				},
// 			},
// 			map[string]interface{}{
// 				"type":      "TagFilters",
// 				"namespace": "AWS/S3",
// 				"tags": []string{
// 					"k2=v2",
// 				},
// 			},
// 		}
// 		collector, err := sumologic.NewCollector(ctx, "collector", &sumologic.CollectorArgs{
// 			Description: pulumi.String("Just testing this"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = sumologic.NewPollingSource(ctx, "s3Audit", &sumologic.PollingSourceArgs{
// 			Description:  pulumi.String("My description"),
// 			Category:     pulumi.String("aws/s3audit"),
// 			ContentType:  pulumi.String("AwsS3AuditBucket"),
// 			ScanInterval: pulumi.Int(300000),
// 			Paused:       pulumi.Bool(false),
// 			CollectorId:  collector.ID(),
// 			Filters: sumologic.PollingSourceFilterArray{
// 				&sumologic.PollingSourceFilterArgs{
// 					Name:       pulumi.String("Exclude Comments"),
// 					FilterType: pulumi.String("Exclude"),
// 					Regexp:     pulumi.String("#.*"),
// 				},
// 			},
// 			Authentication: &sumologic.PollingSourceAuthenticationArgs{
// 				Type:      pulumi.String("S3BucketAuthentication"),
// 				AccessKey: pulumi.String("someKey"),
// 				SecretKey: pulumi.String("******"),
// 			},
// 			Path: &sumologic.PollingSourcePathArgs{
// 				Type:           pulumi.String("S3BucketPathExpression"),
// 				BucketName:     pulumi.String("Bucket1"),
// 				PathExpression: pulumi.String("*"),
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = sumologic.NewPollingSource(ctx, "cwMetrics", &sumologic.PollingSourceArgs{
// 			Description:  pulumi.String("My description"),
// 			Category:     pulumi.String("aws/cw"),
// 			ContentType:  pulumi.String("AwsCloudWatch"),
// 			ScanInterval: pulumi.Int(300000),
// 			Paused:       pulumi.Bool(false),
// 			CollectorId:  collector.ID(),
// 			Authentication: &sumologic.PollingSourceAuthenticationArgs{
// 				Type:    pulumi.String("AWSRoleBasedAuthentication"),
// 				RoleArn: pulumi.String("arn:aws:iam::604066827510:role/cw-role-SumoRole-4AOLS73TGKYI"),
// 			},
// 			Path: &sumologic.PollingSourcePathArgs{
// 				Type: pulumi.String("CloudWatchPath"),
// 				LimitToRegions: pulumi.StringArray{
// 					pulumi.String("us-west-2"),
// 				},
// 				LimitToNamespaces: pulumi.StringArray{
// 					pulumi.String("AWS/Route53"),
// 					pulumi.String("AWS/S3"),
// 					pulumi.String("customNamespace"),
// 				},
// 				Dynamic: pulumi.MapArray{
// 					pulumi.Map{
// 						"forEach": toPulumiMapArray(tagfilters),
// 						"content": pulumi.AnyMapArray{
// 							pulumi.AnyMap{
// 								"type":      pulumi.Any(tag_filters.Value.Type),
// 								"namespace": pulumi.Any(tag_filters.Value.Namespace),
// 								"tags":      pulumi.Any(tag_filters.Value.Tags),
// 							},
// 						},
// 					},
// 				},
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// func toPulumiMapArray(arr []Map) pulumi.MapArray {
// 	var pulumiArr pulumi.MapArray
// 	for _, v := range arr {
// 		pulumiArr = append(pulumiArr, pulumi.Map(v))
// 	}
// 	return pulumiArr
// }
// ```
// ## Argument reference
//
// In addition to the common properties, the following arguments are supported:
//
//  - `contentType` - (Required) The content-type of the collected data. Details can be found in the [Sumologic documentation for hosted sources](https://help.sumologic.com/Send_Data/Sources/03Use_JSON_to_Configure_Sources/JSON_Parameters_for_Hosted_Sources).
//  - `scanInterval` - (Required) Time interval in milliseconds of scans for new data. The default is 300000 and the minimum value is 1000 milliseconds.
//  - `paused` - (Required) When set to true, the scanner is paused. To disable, set to false.
//  - `authentication` - (Required) Authentication details for connecting to the S3 bucket.
//      + `type` - (Required) Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`
//      + `accessKey` - (Required) Your AWS access key if using type `S3BucketAuthentication`
//      + `secretKey` - (Required) Your AWS secret key if using type `S3BucketAuthentication`
//      + `roleArn` - (Required) Your AWS role ARN if using type `AWSRoleBasedAuthentication`
//  - `path` - (Required) The location to scan for new data.
//      + `type` - (Required) type of polling source. Can be one of `S3BucketPathExpression` or  `CloudWatchPath`
//      + `bucketName` - (Optional) The name of the bucket. This is needed if using type `S3BucketPathExpression`.
//      + `pathExpression` - (Optional) The path to the data. This is needed if using type `S3BucketPathExpression`.
//      + `limitToRegions` - (Optional) List of Amazon regions to limit metricscollection. This is a valid parameter if  using type `CloudWatchPath`.
//      + `limitToNamespaces` - (Optional) List of namespaces to limit metrics collection. By default all namespaces are selected. Details can be found [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Amazon-CloudWatch-Source-for-Metrics#aws%C2%A0tag-filtering-namespace-support). You can also  specify custom namespace. This is a valid parameter if using type `CloudWatchPath`.
//      + `tagFilters` - (Optional) Tag filters allow you to filter the CloudWatch metrics you collect by the AWS tags you have assigned to your AWS resources. You can define tag filters for each supported namespace. If you do not define any tag filters, all metrics will be collected for the regions and namespaces you configured for the source above. This is a valid parameter if using type `CloudWatchPath` More info on tag filters can be found [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Amazon-CloudWatch-Source-for-Metrics#about-aws-tag-filtering)
//           + `type` - This value has to be set to `TagFilters`
//           + `namespace` - Namespace for which you want to define the tag filters. Use  value as `All` to apply the tag filter for all namespaces.
//           + `tags` - List of key-value pairs of tag filters. Eg: `["k3=v3"]`
//
// ## Import
//
// Polling sources can be imported using the collector and source IDs (`collector/source`), e.g.hcl
//
// ```sh
//  $ pulumi import sumologic:index/pollingSource:PollingSource test 123/456
// ```
//
//  HTTP sources can be imported using the collector name and source name (`collectorName/sourceName`), e.g.hcl
//
// ```sh
//  $ pulumi import sumologic:index/pollingSource:PollingSource test my-test-collector/my-test-source
// ```
//
//  [1]https://help.sumologic.com/Send_Data/Sources/03Use_JSON_to_Configure_Sources/JSON_Parameters_for_Hosted_Sources
type PollingSource struct {
	pulumi.CustomResourceState

	Authentication             PollingSourceAuthenticationOutput         `pulumi:"authentication"`
	AutomaticDateParsing       pulumi.BoolPtrOutput                      `pulumi:"automaticDateParsing"`
	Category                   pulumi.StringPtrOutput                    `pulumi:"category"`
	CollectorId                pulumi.IntOutput                          `pulumi:"collectorId"`
	ContentType                pulumi.StringOutput                       `pulumi:"contentType"`
	CutoffRelativeTime         pulumi.StringPtrOutput                    `pulumi:"cutoffRelativeTime"`
	CutoffTimestamp            pulumi.IntPtrOutput                       `pulumi:"cutoffTimestamp"`
	DefaultDateFormats         PollingSourceDefaultDateFormatArrayOutput `pulumi:"defaultDateFormats"`
	Description                pulumi.StringPtrOutput                    `pulumi:"description"`
	Fields                     pulumi.StringMapOutput                    `pulumi:"fields"`
	Filters                    PollingSourceFilterArrayOutput            `pulumi:"filters"`
	ForceTimezone              pulumi.BoolPtrOutput                      `pulumi:"forceTimezone"`
	HostName                   pulumi.StringPtrOutput                    `pulumi:"hostName"`
	ManualPrefixRegexp         pulumi.StringPtrOutput                    `pulumi:"manualPrefixRegexp"`
	MultilineProcessingEnabled pulumi.BoolPtrOutput                      `pulumi:"multilineProcessingEnabled"`
	Name                       pulumi.StringOutput                       `pulumi:"name"`
	Path                       PollingSourcePathOutput                   `pulumi:"path"`
	Paused                     pulumi.BoolOutput                         `pulumi:"paused"`
	ScanInterval               pulumi.IntOutput                          `pulumi:"scanInterval"`
	Timezone                   pulumi.StringPtrOutput                    `pulumi:"timezone"`
	// The HTTP endpoint to use with [SNS to notify Sumo Logic of new files](<https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/AWS-S3-Source#Set_up_SNS_in_AWS_(Optional)>).
	Url                 pulumi.StringOutput  `pulumi:"url"`
	UseAutolineMatching pulumi.BoolPtrOutput `pulumi:"useAutolineMatching"`
}

// NewPollingSource registers a new resource with the given unique name, arguments, and options.
func NewPollingSource(ctx *pulumi.Context,
	name string, args *PollingSourceArgs, opts ...pulumi.ResourceOption) (*PollingSource, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Authentication == nil {
		return nil, errors.New("invalid value for required argument 'Authentication'")
	}
	if args.CollectorId == nil {
		return nil, errors.New("invalid value for required argument 'CollectorId'")
	}
	if args.ContentType == nil {
		return nil, errors.New("invalid value for required argument 'ContentType'")
	}
	if args.Path == nil {
		return nil, errors.New("invalid value for required argument 'Path'")
	}
	if args.Paused == nil {
		return nil, errors.New("invalid value for required argument 'Paused'")
	}
	if args.ScanInterval == nil {
		return nil, errors.New("invalid value for required argument 'ScanInterval'")
	}
	var resource PollingSource
	err := ctx.RegisterResource("sumologic:index/pollingSource:PollingSource", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetPollingSource gets an existing PollingSource resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetPollingSource(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *PollingSourceState, opts ...pulumi.ResourceOption) (*PollingSource, error) {
	var resource PollingSource
	err := ctx.ReadResource("sumologic:index/pollingSource:PollingSource", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering PollingSource resources.
type pollingSourceState struct {
	Authentication             *PollingSourceAuthentication     `pulumi:"authentication"`
	AutomaticDateParsing       *bool                            `pulumi:"automaticDateParsing"`
	Category                   *string                          `pulumi:"category"`
	CollectorId                *int                             `pulumi:"collectorId"`
	ContentType                *string                          `pulumi:"contentType"`
	CutoffRelativeTime         *string                          `pulumi:"cutoffRelativeTime"`
	CutoffTimestamp            *int                             `pulumi:"cutoffTimestamp"`
	DefaultDateFormats         []PollingSourceDefaultDateFormat `pulumi:"defaultDateFormats"`
	Description                *string                          `pulumi:"description"`
	Fields                     map[string]string                `pulumi:"fields"`
	Filters                    []PollingSourceFilter            `pulumi:"filters"`
	ForceTimezone              *bool                            `pulumi:"forceTimezone"`
	HostName                   *string                          `pulumi:"hostName"`
	ManualPrefixRegexp         *string                          `pulumi:"manualPrefixRegexp"`
	MultilineProcessingEnabled *bool                            `pulumi:"multilineProcessingEnabled"`
	Name                       *string                          `pulumi:"name"`
	Path                       *PollingSourcePath               `pulumi:"path"`
	Paused                     *bool                            `pulumi:"paused"`
	ScanInterval               *int                             `pulumi:"scanInterval"`
	Timezone                   *string                          `pulumi:"timezone"`
	// The HTTP endpoint to use with [SNS to notify Sumo Logic of new files](<https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/AWS-S3-Source#Set_up_SNS_in_AWS_(Optional)>).
	Url                 *string `pulumi:"url"`
	UseAutolineMatching *bool   `pulumi:"useAutolineMatching"`
}

type PollingSourceState struct {
	Authentication             PollingSourceAuthenticationPtrInput
	AutomaticDateParsing       pulumi.BoolPtrInput
	Category                   pulumi.StringPtrInput
	CollectorId                pulumi.IntPtrInput
	ContentType                pulumi.StringPtrInput
	CutoffRelativeTime         pulumi.StringPtrInput
	CutoffTimestamp            pulumi.IntPtrInput
	DefaultDateFormats         PollingSourceDefaultDateFormatArrayInput
	Description                pulumi.StringPtrInput
	Fields                     pulumi.StringMapInput
	Filters                    PollingSourceFilterArrayInput
	ForceTimezone              pulumi.BoolPtrInput
	HostName                   pulumi.StringPtrInput
	ManualPrefixRegexp         pulumi.StringPtrInput
	MultilineProcessingEnabled pulumi.BoolPtrInput
	Name                       pulumi.StringPtrInput
	Path                       PollingSourcePathPtrInput
	Paused                     pulumi.BoolPtrInput
	ScanInterval               pulumi.IntPtrInput
	Timezone                   pulumi.StringPtrInput
	// The HTTP endpoint to use with [SNS to notify Sumo Logic of new files](<https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/AWS-S3-Source#Set_up_SNS_in_AWS_(Optional)>).
	Url                 pulumi.StringPtrInput
	UseAutolineMatching pulumi.BoolPtrInput
}

func (PollingSourceState) ElementType() reflect.Type {
	return reflect.TypeOf((*pollingSourceState)(nil)).Elem()
}

type pollingSourceArgs struct {
	Authentication             PollingSourceAuthentication      `pulumi:"authentication"`
	AutomaticDateParsing       *bool                            `pulumi:"automaticDateParsing"`
	Category                   *string                          `pulumi:"category"`
	CollectorId                int                              `pulumi:"collectorId"`
	ContentType                string                           `pulumi:"contentType"`
	CutoffRelativeTime         *string                          `pulumi:"cutoffRelativeTime"`
	CutoffTimestamp            *int                             `pulumi:"cutoffTimestamp"`
	DefaultDateFormats         []PollingSourceDefaultDateFormat `pulumi:"defaultDateFormats"`
	Description                *string                          `pulumi:"description"`
	Fields                     map[string]string                `pulumi:"fields"`
	Filters                    []PollingSourceFilter            `pulumi:"filters"`
	ForceTimezone              *bool                            `pulumi:"forceTimezone"`
	HostName                   *string                          `pulumi:"hostName"`
	ManualPrefixRegexp         *string                          `pulumi:"manualPrefixRegexp"`
	MultilineProcessingEnabled *bool                            `pulumi:"multilineProcessingEnabled"`
	Name                       *string                          `pulumi:"name"`
	Path                       PollingSourcePath                `pulumi:"path"`
	Paused                     bool                             `pulumi:"paused"`
	ScanInterval               int                              `pulumi:"scanInterval"`
	Timezone                   *string                          `pulumi:"timezone"`
	UseAutolineMatching        *bool                            `pulumi:"useAutolineMatching"`
}

// The set of arguments for constructing a PollingSource resource.
type PollingSourceArgs struct {
	Authentication             PollingSourceAuthenticationInput
	AutomaticDateParsing       pulumi.BoolPtrInput
	Category                   pulumi.StringPtrInput
	CollectorId                pulumi.IntInput
	ContentType                pulumi.StringInput
	CutoffRelativeTime         pulumi.StringPtrInput
	CutoffTimestamp            pulumi.IntPtrInput
	DefaultDateFormats         PollingSourceDefaultDateFormatArrayInput
	Description                pulumi.StringPtrInput
	Fields                     pulumi.StringMapInput
	Filters                    PollingSourceFilterArrayInput
	ForceTimezone              pulumi.BoolPtrInput
	HostName                   pulumi.StringPtrInput
	ManualPrefixRegexp         pulumi.StringPtrInput
	MultilineProcessingEnabled pulumi.BoolPtrInput
	Name                       pulumi.StringPtrInput
	Path                       PollingSourcePathInput
	Paused                     pulumi.BoolInput
	ScanInterval               pulumi.IntInput
	Timezone                   pulumi.StringPtrInput
	UseAutolineMatching        pulumi.BoolPtrInput
}

func (PollingSourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*pollingSourceArgs)(nil)).Elem()
}

type PollingSourceInput interface {
	pulumi.Input

	ToPollingSourceOutput() PollingSourceOutput
	ToPollingSourceOutputWithContext(ctx context.Context) PollingSourceOutput
}

func (*PollingSource) ElementType() reflect.Type {
	return reflect.TypeOf((*PollingSource)(nil))
}

func (i *PollingSource) ToPollingSourceOutput() PollingSourceOutput {
	return i.ToPollingSourceOutputWithContext(context.Background())
}

func (i *PollingSource) ToPollingSourceOutputWithContext(ctx context.Context) PollingSourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PollingSourceOutput)
}

func (i *PollingSource) ToPollingSourcePtrOutput() PollingSourcePtrOutput {
	return i.ToPollingSourcePtrOutputWithContext(context.Background())
}

func (i *PollingSource) ToPollingSourcePtrOutputWithContext(ctx context.Context) PollingSourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PollingSourcePtrOutput)
}

type PollingSourcePtrInput interface {
	pulumi.Input

	ToPollingSourcePtrOutput() PollingSourcePtrOutput
	ToPollingSourcePtrOutputWithContext(ctx context.Context) PollingSourcePtrOutput
}

type pollingSourcePtrType PollingSourceArgs

func (*pollingSourcePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**PollingSource)(nil))
}

func (i *pollingSourcePtrType) ToPollingSourcePtrOutput() PollingSourcePtrOutput {
	return i.ToPollingSourcePtrOutputWithContext(context.Background())
}

func (i *pollingSourcePtrType) ToPollingSourcePtrOutputWithContext(ctx context.Context) PollingSourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PollingSourcePtrOutput)
}

// PollingSourceArrayInput is an input type that accepts PollingSourceArray and PollingSourceArrayOutput values.
// You can construct a concrete instance of `PollingSourceArrayInput` via:
//
//          PollingSourceArray{ PollingSourceArgs{...} }
type PollingSourceArrayInput interface {
	pulumi.Input

	ToPollingSourceArrayOutput() PollingSourceArrayOutput
	ToPollingSourceArrayOutputWithContext(context.Context) PollingSourceArrayOutput
}

type PollingSourceArray []PollingSourceInput

func (PollingSourceArray) ElementType() reflect.Type {
	return reflect.TypeOf(([]*PollingSource)(nil))
}

func (i PollingSourceArray) ToPollingSourceArrayOutput() PollingSourceArrayOutput {
	return i.ToPollingSourceArrayOutputWithContext(context.Background())
}

func (i PollingSourceArray) ToPollingSourceArrayOutputWithContext(ctx context.Context) PollingSourceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PollingSourceArrayOutput)
}

// PollingSourceMapInput is an input type that accepts PollingSourceMap and PollingSourceMapOutput values.
// You can construct a concrete instance of `PollingSourceMapInput` via:
//
//          PollingSourceMap{ "key": PollingSourceArgs{...} }
type PollingSourceMapInput interface {
	pulumi.Input

	ToPollingSourceMapOutput() PollingSourceMapOutput
	ToPollingSourceMapOutputWithContext(context.Context) PollingSourceMapOutput
}

type PollingSourceMap map[string]PollingSourceInput

func (PollingSourceMap) ElementType() reflect.Type {
	return reflect.TypeOf((map[string]*PollingSource)(nil))
}

func (i PollingSourceMap) ToPollingSourceMapOutput() PollingSourceMapOutput {
	return i.ToPollingSourceMapOutputWithContext(context.Background())
}

func (i PollingSourceMap) ToPollingSourceMapOutputWithContext(ctx context.Context) PollingSourceMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(PollingSourceMapOutput)
}

type PollingSourceOutput struct {
	*pulumi.OutputState
}

func (PollingSourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*PollingSource)(nil))
}

func (o PollingSourceOutput) ToPollingSourceOutput() PollingSourceOutput {
	return o
}

func (o PollingSourceOutput) ToPollingSourceOutputWithContext(ctx context.Context) PollingSourceOutput {
	return o
}

func (o PollingSourceOutput) ToPollingSourcePtrOutput() PollingSourcePtrOutput {
	return o.ToPollingSourcePtrOutputWithContext(context.Background())
}

func (o PollingSourceOutput) ToPollingSourcePtrOutputWithContext(ctx context.Context) PollingSourcePtrOutput {
	return o.ApplyT(func(v PollingSource) *PollingSource {
		return &v
	}).(PollingSourcePtrOutput)
}

type PollingSourcePtrOutput struct {
	*pulumi.OutputState
}

func (PollingSourcePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**PollingSource)(nil))
}

func (o PollingSourcePtrOutput) ToPollingSourcePtrOutput() PollingSourcePtrOutput {
	return o
}

func (o PollingSourcePtrOutput) ToPollingSourcePtrOutputWithContext(ctx context.Context) PollingSourcePtrOutput {
	return o
}

type PollingSourceArrayOutput struct{ *pulumi.OutputState }

func (PollingSourceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]PollingSource)(nil))
}

func (o PollingSourceArrayOutput) ToPollingSourceArrayOutput() PollingSourceArrayOutput {
	return o
}

func (o PollingSourceArrayOutput) ToPollingSourceArrayOutputWithContext(ctx context.Context) PollingSourceArrayOutput {
	return o
}

func (o PollingSourceArrayOutput) Index(i pulumi.IntInput) PollingSourceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) PollingSource {
		return vs[0].([]PollingSource)[vs[1].(int)]
	}).(PollingSourceOutput)
}

type PollingSourceMapOutput struct{ *pulumi.OutputState }

func (PollingSourceMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]PollingSource)(nil))
}

func (o PollingSourceMapOutput) ToPollingSourceMapOutput() PollingSourceMapOutput {
	return o
}

func (o PollingSourceMapOutput) ToPollingSourceMapOutputWithContext(ctx context.Context) PollingSourceMapOutput {
	return o
}

func (o PollingSourceMapOutput) MapIndex(k pulumi.StringInput) PollingSourceOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) PollingSource {
		return vs[0].(map[string]PollingSource)[vs[1].(string)]
	}).(PollingSourceOutput)
}

func init() {
	pulumi.RegisterOutputType(PollingSourceOutput{})
	pulumi.RegisterOutputType(PollingSourcePtrOutput{})
	pulumi.RegisterOutputType(PollingSourceArrayOutput{})
	pulumi.RegisterOutputType(PollingSourceMapOutput{})
}
