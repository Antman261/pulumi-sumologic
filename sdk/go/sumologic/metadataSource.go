// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package sumologic

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a Sumologic Metadata (Tag) source. This source allows you to collect tags from EC2 instances running on AWS.
//
// __IMPORTANT:__ The AWS credentials are stored in plain-text in the state. This is a potential security issue.
//
// ## Argument reference
//
// In addition to the common properties, the following arguments are supported:
//
//  - `contentType` - (Required) The content-type of the collected data. For Metadata source this is `AwsMetadata`. Details can be found in the [Sumologic documentation for hosted sources](https://help.sumologic.com/Send_Data/Sources/03Use_JSON_to_Configure_Sources/JSON_Parameters_for_Hosted_Sources).
//  - `scanInterval` - (Required) Time interval in milliseconds of scans for new data. The default is 300000 and the minimum value is 1000 milliseconds.
//  - `paused` - (Required) When set to true, the scanner is paused. To disable, set to false.
//  - `authentication` - (Required) Authentication details for AWS access.
//      + `type` - (Required) Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`
//      + `accessKey` - (Required) Your AWS access key if using type `S3BucketAuthentication`
//      + `secretKey` - (Required) Your AWS secret key if using type `S3BucketAuthentication`
//      + `roleArn` - (Required) Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
//      + `region` - (Optional) Your AWS Bucket region.
//  - `path` - (Required) The location to scan for new data.
//      + `type` - (Required) type of polling source. Only allowed value is `AwsMetadataPath`.
//      + `limitToRegions` - (Optional) List of Amazon regions.
//      + `limitToNamespaces` - List of namespaces. For `AwsMetadataPath` the only valid namespace is `AWS/EC2`.
//      + `tagFilters` - (Optional) Leave this field blank to collect all tags configured for the EC2 instance. To collect a subset of tags, follow the instructions in [Define EC2 tag filters][2]
//
// ### See also
//   * [Sumologic > Sources > Sources for Hosted Collectors > AWS > AWS Metadata (Tag) Source][3]
//
// ## Import
//
// Metadata sources can be imported using the collector and source IDs (`collector/source`), e.g.hcl
//
// ```sh
//  $ pulumi import sumologic:index/metadataSource:MetadataSource test 123/456
// ```
//
//  Metadata sources can be imported using the collector name and source name (`collectorName/sourceName`), e.g.hcl
//
// ```sh
//  $ pulumi import sumologic:index/metadataSource:MetadataSource test my-test-collector/my-test-source
// ```
//
//  [1]https://help.sumologic.com/Send_Data/Sources/03Use_JSON_to_Configure_Sources/JSON_Parameters_for_Hosted_Sources [2]:https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/AWS-Metadata-(Tag)-Source#Define_EC2_tag_filters [3]:https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/AWS-Metadata-(Tag)-Source
type MetadataSource struct {
	pulumi.CustomResourceState

	Authentication             MetadataSourceAuthenticationOutput         `pulumi:"authentication"`
	AutomaticDateParsing       pulumi.BoolPtrOutput                       `pulumi:"automaticDateParsing"`
	Category                   pulumi.StringPtrOutput                     `pulumi:"category"`
	CollectorId                pulumi.IntOutput                           `pulumi:"collectorId"`
	ContentType                pulumi.StringOutput                        `pulumi:"contentType"`
	CutoffRelativeTime         pulumi.StringPtrOutput                     `pulumi:"cutoffRelativeTime"`
	CutoffTimestamp            pulumi.IntPtrOutput                        `pulumi:"cutoffTimestamp"`
	DefaultDateFormats         MetadataSourceDefaultDateFormatArrayOutput `pulumi:"defaultDateFormats"`
	Description                pulumi.StringPtrOutput                     `pulumi:"description"`
	Fields                     pulumi.StringMapOutput                     `pulumi:"fields"`
	Filters                    MetadataSourceFilterArrayOutput            `pulumi:"filters"`
	ForceTimezone              pulumi.BoolPtrOutput                       `pulumi:"forceTimezone"`
	HostName                   pulumi.StringPtrOutput                     `pulumi:"hostName"`
	ManualPrefixRegexp         pulumi.StringPtrOutput                     `pulumi:"manualPrefixRegexp"`
	MultilineProcessingEnabled pulumi.BoolPtrOutput                       `pulumi:"multilineProcessingEnabled"`
	Name                       pulumi.StringOutput                        `pulumi:"name"`
	Path                       MetadataSourcePathOutput                   `pulumi:"path"`
	Paused                     pulumi.BoolOutput                          `pulumi:"paused"`
	ScanInterval               pulumi.IntOutput                           `pulumi:"scanInterval"`
	Timezone                   pulumi.StringPtrOutput                     `pulumi:"timezone"`
	// The HTTP endpoint to use with [SNS to notify Sumo Logic of new files](<https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/AWS-S3-Source#Set_up_SNS_in_AWS_(Optional)>).
	Url                 pulumi.StringOutput  `pulumi:"url"`
	UseAutolineMatching pulumi.BoolPtrOutput `pulumi:"useAutolineMatching"`
}

// NewMetadataSource registers a new resource with the given unique name, arguments, and options.
func NewMetadataSource(ctx *pulumi.Context,
	name string, args *MetadataSourceArgs, opts ...pulumi.ResourceOption) (*MetadataSource, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Authentication == nil {
		return nil, errors.New("invalid value for required argument 'Authentication'")
	}
	if args.CollectorId == nil {
		return nil, errors.New("invalid value for required argument 'CollectorId'")
	}
	if args.ContentType == nil {
		return nil, errors.New("invalid value for required argument 'ContentType'")
	}
	if args.Path == nil {
		return nil, errors.New("invalid value for required argument 'Path'")
	}
	if args.Paused == nil {
		return nil, errors.New("invalid value for required argument 'Paused'")
	}
	if args.ScanInterval == nil {
		return nil, errors.New("invalid value for required argument 'ScanInterval'")
	}
	var resource MetadataSource
	err := ctx.RegisterResource("sumologic:index/metadataSource:MetadataSource", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetMetadataSource gets an existing MetadataSource resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetMetadataSource(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *MetadataSourceState, opts ...pulumi.ResourceOption) (*MetadataSource, error) {
	var resource MetadataSource
	err := ctx.ReadResource("sumologic:index/metadataSource:MetadataSource", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering MetadataSource resources.
type metadataSourceState struct {
	Authentication             *MetadataSourceAuthentication     `pulumi:"authentication"`
	AutomaticDateParsing       *bool                             `pulumi:"automaticDateParsing"`
	Category                   *string                           `pulumi:"category"`
	CollectorId                *int                              `pulumi:"collectorId"`
	ContentType                *string                           `pulumi:"contentType"`
	CutoffRelativeTime         *string                           `pulumi:"cutoffRelativeTime"`
	CutoffTimestamp            *int                              `pulumi:"cutoffTimestamp"`
	DefaultDateFormats         []MetadataSourceDefaultDateFormat `pulumi:"defaultDateFormats"`
	Description                *string                           `pulumi:"description"`
	Fields                     map[string]string                 `pulumi:"fields"`
	Filters                    []MetadataSourceFilter            `pulumi:"filters"`
	ForceTimezone              *bool                             `pulumi:"forceTimezone"`
	HostName                   *string                           `pulumi:"hostName"`
	ManualPrefixRegexp         *string                           `pulumi:"manualPrefixRegexp"`
	MultilineProcessingEnabled *bool                             `pulumi:"multilineProcessingEnabled"`
	Name                       *string                           `pulumi:"name"`
	Path                       *MetadataSourcePath               `pulumi:"path"`
	Paused                     *bool                             `pulumi:"paused"`
	ScanInterval               *int                              `pulumi:"scanInterval"`
	Timezone                   *string                           `pulumi:"timezone"`
	// The HTTP endpoint to use with [SNS to notify Sumo Logic of new files](<https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/AWS-S3-Source#Set_up_SNS_in_AWS_(Optional)>).
	Url                 *string `pulumi:"url"`
	UseAutolineMatching *bool   `pulumi:"useAutolineMatching"`
}

type MetadataSourceState struct {
	Authentication             MetadataSourceAuthenticationPtrInput
	AutomaticDateParsing       pulumi.BoolPtrInput
	Category                   pulumi.StringPtrInput
	CollectorId                pulumi.IntPtrInput
	ContentType                pulumi.StringPtrInput
	CutoffRelativeTime         pulumi.StringPtrInput
	CutoffTimestamp            pulumi.IntPtrInput
	DefaultDateFormats         MetadataSourceDefaultDateFormatArrayInput
	Description                pulumi.StringPtrInput
	Fields                     pulumi.StringMapInput
	Filters                    MetadataSourceFilterArrayInput
	ForceTimezone              pulumi.BoolPtrInput
	HostName                   pulumi.StringPtrInput
	ManualPrefixRegexp         pulumi.StringPtrInput
	MultilineProcessingEnabled pulumi.BoolPtrInput
	Name                       pulumi.StringPtrInput
	Path                       MetadataSourcePathPtrInput
	Paused                     pulumi.BoolPtrInput
	ScanInterval               pulumi.IntPtrInput
	Timezone                   pulumi.StringPtrInput
	// The HTTP endpoint to use with [SNS to notify Sumo Logic of new files](<https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/AWS-S3-Source#Set_up_SNS_in_AWS_(Optional)>).
	Url                 pulumi.StringPtrInput
	UseAutolineMatching pulumi.BoolPtrInput
}

func (MetadataSourceState) ElementType() reflect.Type {
	return reflect.TypeOf((*metadataSourceState)(nil)).Elem()
}

type metadataSourceArgs struct {
	Authentication             MetadataSourceAuthentication      `pulumi:"authentication"`
	AutomaticDateParsing       *bool                             `pulumi:"automaticDateParsing"`
	Category                   *string                           `pulumi:"category"`
	CollectorId                int                               `pulumi:"collectorId"`
	ContentType                string                            `pulumi:"contentType"`
	CutoffRelativeTime         *string                           `pulumi:"cutoffRelativeTime"`
	CutoffTimestamp            *int                              `pulumi:"cutoffTimestamp"`
	DefaultDateFormats         []MetadataSourceDefaultDateFormat `pulumi:"defaultDateFormats"`
	Description                *string                           `pulumi:"description"`
	Fields                     map[string]string                 `pulumi:"fields"`
	Filters                    []MetadataSourceFilter            `pulumi:"filters"`
	ForceTimezone              *bool                             `pulumi:"forceTimezone"`
	HostName                   *string                           `pulumi:"hostName"`
	ManualPrefixRegexp         *string                           `pulumi:"manualPrefixRegexp"`
	MultilineProcessingEnabled *bool                             `pulumi:"multilineProcessingEnabled"`
	Name                       *string                           `pulumi:"name"`
	Path                       MetadataSourcePath                `pulumi:"path"`
	Paused                     bool                              `pulumi:"paused"`
	ScanInterval               int                               `pulumi:"scanInterval"`
	Timezone                   *string                           `pulumi:"timezone"`
	UseAutolineMatching        *bool                             `pulumi:"useAutolineMatching"`
}

// The set of arguments for constructing a MetadataSource resource.
type MetadataSourceArgs struct {
	Authentication             MetadataSourceAuthenticationInput
	AutomaticDateParsing       pulumi.BoolPtrInput
	Category                   pulumi.StringPtrInput
	CollectorId                pulumi.IntInput
	ContentType                pulumi.StringInput
	CutoffRelativeTime         pulumi.StringPtrInput
	CutoffTimestamp            pulumi.IntPtrInput
	DefaultDateFormats         MetadataSourceDefaultDateFormatArrayInput
	Description                pulumi.StringPtrInput
	Fields                     pulumi.StringMapInput
	Filters                    MetadataSourceFilterArrayInput
	ForceTimezone              pulumi.BoolPtrInput
	HostName                   pulumi.StringPtrInput
	ManualPrefixRegexp         pulumi.StringPtrInput
	MultilineProcessingEnabled pulumi.BoolPtrInput
	Name                       pulumi.StringPtrInput
	Path                       MetadataSourcePathInput
	Paused                     pulumi.BoolInput
	ScanInterval               pulumi.IntInput
	Timezone                   pulumi.StringPtrInput
	UseAutolineMatching        pulumi.BoolPtrInput
}

func (MetadataSourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*metadataSourceArgs)(nil)).Elem()
}

type MetadataSourceInput interface {
	pulumi.Input

	ToMetadataSourceOutput() MetadataSourceOutput
	ToMetadataSourceOutputWithContext(ctx context.Context) MetadataSourceOutput
}

func (*MetadataSource) ElementType() reflect.Type {
	return reflect.TypeOf((*MetadataSource)(nil))
}

func (i *MetadataSource) ToMetadataSourceOutput() MetadataSourceOutput {
	return i.ToMetadataSourceOutputWithContext(context.Background())
}

func (i *MetadataSource) ToMetadataSourceOutputWithContext(ctx context.Context) MetadataSourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetadataSourceOutput)
}

func (i *MetadataSource) ToMetadataSourcePtrOutput() MetadataSourcePtrOutput {
	return i.ToMetadataSourcePtrOutputWithContext(context.Background())
}

func (i *MetadataSource) ToMetadataSourcePtrOutputWithContext(ctx context.Context) MetadataSourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetadataSourcePtrOutput)
}

type MetadataSourcePtrInput interface {
	pulumi.Input

	ToMetadataSourcePtrOutput() MetadataSourcePtrOutput
	ToMetadataSourcePtrOutputWithContext(ctx context.Context) MetadataSourcePtrOutput
}

type metadataSourcePtrType MetadataSourceArgs

func (*metadataSourcePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**MetadataSource)(nil))
}

func (i *metadataSourcePtrType) ToMetadataSourcePtrOutput() MetadataSourcePtrOutput {
	return i.ToMetadataSourcePtrOutputWithContext(context.Background())
}

func (i *metadataSourcePtrType) ToMetadataSourcePtrOutputWithContext(ctx context.Context) MetadataSourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetadataSourcePtrOutput)
}

// MetadataSourceArrayInput is an input type that accepts MetadataSourceArray and MetadataSourceArrayOutput values.
// You can construct a concrete instance of `MetadataSourceArrayInput` via:
//
//          MetadataSourceArray{ MetadataSourceArgs{...} }
type MetadataSourceArrayInput interface {
	pulumi.Input

	ToMetadataSourceArrayOutput() MetadataSourceArrayOutput
	ToMetadataSourceArrayOutputWithContext(context.Context) MetadataSourceArrayOutput
}

type MetadataSourceArray []MetadataSourceInput

func (MetadataSourceArray) ElementType() reflect.Type {
	return reflect.TypeOf(([]*MetadataSource)(nil))
}

func (i MetadataSourceArray) ToMetadataSourceArrayOutput() MetadataSourceArrayOutput {
	return i.ToMetadataSourceArrayOutputWithContext(context.Background())
}

func (i MetadataSourceArray) ToMetadataSourceArrayOutputWithContext(ctx context.Context) MetadataSourceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetadataSourceArrayOutput)
}

// MetadataSourceMapInput is an input type that accepts MetadataSourceMap and MetadataSourceMapOutput values.
// You can construct a concrete instance of `MetadataSourceMapInput` via:
//
//          MetadataSourceMap{ "key": MetadataSourceArgs{...} }
type MetadataSourceMapInput interface {
	pulumi.Input

	ToMetadataSourceMapOutput() MetadataSourceMapOutput
	ToMetadataSourceMapOutputWithContext(context.Context) MetadataSourceMapOutput
}

type MetadataSourceMap map[string]MetadataSourceInput

func (MetadataSourceMap) ElementType() reflect.Type {
	return reflect.TypeOf((map[string]*MetadataSource)(nil))
}

func (i MetadataSourceMap) ToMetadataSourceMapOutput() MetadataSourceMapOutput {
	return i.ToMetadataSourceMapOutputWithContext(context.Background())
}

func (i MetadataSourceMap) ToMetadataSourceMapOutputWithContext(ctx context.Context) MetadataSourceMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(MetadataSourceMapOutput)
}

type MetadataSourceOutput struct {
	*pulumi.OutputState
}

func (MetadataSourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*MetadataSource)(nil))
}

func (o MetadataSourceOutput) ToMetadataSourceOutput() MetadataSourceOutput {
	return o
}

func (o MetadataSourceOutput) ToMetadataSourceOutputWithContext(ctx context.Context) MetadataSourceOutput {
	return o
}

func (o MetadataSourceOutput) ToMetadataSourcePtrOutput() MetadataSourcePtrOutput {
	return o.ToMetadataSourcePtrOutputWithContext(context.Background())
}

func (o MetadataSourceOutput) ToMetadataSourcePtrOutputWithContext(ctx context.Context) MetadataSourcePtrOutput {
	return o.ApplyT(func(v MetadataSource) *MetadataSource {
		return &v
	}).(MetadataSourcePtrOutput)
}

type MetadataSourcePtrOutput struct {
	*pulumi.OutputState
}

func (MetadataSourcePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**MetadataSource)(nil))
}

func (o MetadataSourcePtrOutput) ToMetadataSourcePtrOutput() MetadataSourcePtrOutput {
	return o
}

func (o MetadataSourcePtrOutput) ToMetadataSourcePtrOutputWithContext(ctx context.Context) MetadataSourcePtrOutput {
	return o
}

type MetadataSourceArrayOutput struct{ *pulumi.OutputState }

func (MetadataSourceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]MetadataSource)(nil))
}

func (o MetadataSourceArrayOutput) ToMetadataSourceArrayOutput() MetadataSourceArrayOutput {
	return o
}

func (o MetadataSourceArrayOutput) ToMetadataSourceArrayOutputWithContext(ctx context.Context) MetadataSourceArrayOutput {
	return o
}

func (o MetadataSourceArrayOutput) Index(i pulumi.IntInput) MetadataSourceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) MetadataSource {
		return vs[0].([]MetadataSource)[vs[1].(int)]
	}).(MetadataSourceOutput)
}

type MetadataSourceMapOutput struct{ *pulumi.OutputState }

func (MetadataSourceMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]MetadataSource)(nil))
}

func (o MetadataSourceMapOutput) ToMetadataSourceMapOutput() MetadataSourceMapOutput {
	return o
}

func (o MetadataSourceMapOutput) ToMetadataSourceMapOutputWithContext(ctx context.Context) MetadataSourceMapOutput {
	return o
}

func (o MetadataSourceMapOutput) MapIndex(k pulumi.StringInput) MetadataSourceOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) MetadataSource {
		return vs[0].(map[string]MetadataSource)[vs[1].(string)]
	}).(MetadataSourceOutput)
}

func init() {
	pulumi.RegisterOutputType(MetadataSourceOutput{})
	pulumi.RegisterOutputType(MetadataSourcePtrOutput{})
	pulumi.RegisterOutputType(MetadataSourceArrayOutput{})
	pulumi.RegisterOutputType(MetadataSourceMapOutput{})
}
