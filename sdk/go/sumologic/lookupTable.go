// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package sumologic

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a [Sumologic Lookup Table](https://help.sumologic.com/05Search/Lookup_Tables).
//
// ## Example Usage
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-sumologic/sdk/go/sumologic"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		_, err := sumologic.NewLookupTable(ctx, "lookupTable", &sumologic.LookupTableArgs{
// 			Description: pulumi.String("some description"),
// 			Fields: sumologic.LookupTableFieldArray{
// 				&sumologic.LookupTableFieldArgs{
// 					FieldName: "FieldName1",
// 					FieldType: "boolean",
// 				},
// 				&sumologic.LookupTableFieldArgs{
// 					FieldName: "FieldName2",
// 					FieldType: "string",
// 				},
// 			},
// 			ParentFolderId: pulumi.String("<personal folder id>"),
// 			PrimaryKeys: pulumi.StringArray{
// 				pulumi.String("FieldName1"),
// 			},
// 			SizeLimitAction: pulumi.String("DeleteOldData"),
// 			Ttl:             pulumi.Int(100),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
// ## Argument reference
//
// The following arguments are supported:
//
// - `name` - (Required) The name of the lookup table.
// - `parentFolderId` - (Required) The parent-folder-path identifier of the lookup table in the Library.
// - `description` - (Required) The description of the lookup table.
// - `fields` - (Required) The list of fields in the lookup table.
//   - `fieldName` - (Required) The name of the field.
//   - `fieldType` - (Required) The data type of the field. Supported types: boolean, int, long, double, string
// - `primaryKeys` - (Required) The names of the fields that make up the primary key for the lookup table. These will be a subset of the fields that the table will contain.
// - `ttl` - (Optional) A time to live for each entry in the lookup table (in minutes). 365 days is the maximum time to live for each entry that you can specify. Setting it to 0 means that the records will not expire automatically.
// - `sizeLimitAction` - (Optional) The action that needs to be taken when the size limit is reached for the table. The possible values can be StopIncomingMessages or DeleteOldData. DeleteOldData will start deleting old data once size limit is reached whereas StopIncomingMessages will discard all the updates made to the lookup table once size limit is reached.
//
// ## Attributes reference
//
// The following attributes are exported:
//
// - `id` - Unique identifier for the partition.
//
// ## Import
//
// Lookup Tables can be imported using the id, e.g.hcl
//
// ```sh
//  $ pulumi import sumologic:index/lookupTable:LookupTable test 1234567890
// ```
//
//  [1]https://help.sumologic.com/05Search/Lookup_Tables
type LookupTable struct {
	pulumi.CustomResourceState

	Description pulumi.StringOutput `pulumi:"description"`
	// The list of fields in the lookup table.
	Fields         LookupTableFieldArrayOutput `pulumi:"fields"`
	Name           pulumi.StringOutput         `pulumi:"name"`
	ParentFolderId pulumi.StringPtrOutput      `pulumi:"parentFolderId"`
	// The primary key field names.
	PrimaryKeys     pulumi.StringArrayOutput `pulumi:"primaryKeys"`
	SizeLimitAction pulumi.StringPtrOutput   `pulumi:"sizeLimitAction"`
	Ttl             pulumi.IntPtrOutput      `pulumi:"ttl"`
}

// NewLookupTable registers a new resource with the given unique name, arguments, and options.
func NewLookupTable(ctx *pulumi.Context,
	name string, args *LookupTableArgs, opts ...pulumi.ResourceOption) (*LookupTable, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Description == nil {
		return nil, errors.New("invalid value for required argument 'Description'")
	}
	var resource LookupTable
	err := ctx.RegisterResource("sumologic:index/lookupTable:LookupTable", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetLookupTable gets an existing LookupTable resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetLookupTable(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *LookupTableState, opts ...pulumi.ResourceOption) (*LookupTable, error) {
	var resource LookupTable
	err := ctx.ReadResource("sumologic:index/lookupTable:LookupTable", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering LookupTable resources.
type lookupTableState struct {
	Description *string `pulumi:"description"`
	// The list of fields in the lookup table.
	Fields         []LookupTableField `pulumi:"fields"`
	Name           *string            `pulumi:"name"`
	ParentFolderId *string            `pulumi:"parentFolderId"`
	// The primary key field names.
	PrimaryKeys     []string `pulumi:"primaryKeys"`
	SizeLimitAction *string  `pulumi:"sizeLimitAction"`
	Ttl             *int     `pulumi:"ttl"`
}

type LookupTableState struct {
	Description pulumi.StringPtrInput
	// The list of fields in the lookup table.
	Fields         LookupTableFieldArrayInput
	Name           pulumi.StringPtrInput
	ParentFolderId pulumi.StringPtrInput
	// The primary key field names.
	PrimaryKeys     pulumi.StringArrayInput
	SizeLimitAction pulumi.StringPtrInput
	Ttl             pulumi.IntPtrInput
}

func (LookupTableState) ElementType() reflect.Type {
	return reflect.TypeOf((*lookupTableState)(nil)).Elem()
}

type lookupTableArgs struct {
	Description string `pulumi:"description"`
	// The list of fields in the lookup table.
	Fields         []LookupTableField `pulumi:"fields"`
	Name           *string            `pulumi:"name"`
	ParentFolderId *string            `pulumi:"parentFolderId"`
	// The primary key field names.
	PrimaryKeys     []string `pulumi:"primaryKeys"`
	SizeLimitAction *string  `pulumi:"sizeLimitAction"`
	Ttl             *int     `pulumi:"ttl"`
}

// The set of arguments for constructing a LookupTable resource.
type LookupTableArgs struct {
	Description pulumi.StringInput
	// The list of fields in the lookup table.
	Fields         LookupTableFieldArrayInput
	Name           pulumi.StringPtrInput
	ParentFolderId pulumi.StringPtrInput
	// The primary key field names.
	PrimaryKeys     pulumi.StringArrayInput
	SizeLimitAction pulumi.StringPtrInput
	Ttl             pulumi.IntPtrInput
}

func (LookupTableArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*lookupTableArgs)(nil)).Elem()
}

type LookupTableInput interface {
	pulumi.Input

	ToLookupTableOutput() LookupTableOutput
	ToLookupTableOutputWithContext(ctx context.Context) LookupTableOutput
}

func (*LookupTable) ElementType() reflect.Type {
	return reflect.TypeOf((*LookupTable)(nil))
}

func (i *LookupTable) ToLookupTableOutput() LookupTableOutput {
	return i.ToLookupTableOutputWithContext(context.Background())
}

func (i *LookupTable) ToLookupTableOutputWithContext(ctx context.Context) LookupTableOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LookupTableOutput)
}

func (i *LookupTable) ToLookupTablePtrOutput() LookupTablePtrOutput {
	return i.ToLookupTablePtrOutputWithContext(context.Background())
}

func (i *LookupTable) ToLookupTablePtrOutputWithContext(ctx context.Context) LookupTablePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LookupTablePtrOutput)
}

type LookupTablePtrInput interface {
	pulumi.Input

	ToLookupTablePtrOutput() LookupTablePtrOutput
	ToLookupTablePtrOutputWithContext(ctx context.Context) LookupTablePtrOutput
}

type lookupTablePtrType LookupTableArgs

func (*lookupTablePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LookupTable)(nil))
}

func (i *lookupTablePtrType) ToLookupTablePtrOutput() LookupTablePtrOutput {
	return i.ToLookupTablePtrOutputWithContext(context.Background())
}

func (i *lookupTablePtrType) ToLookupTablePtrOutputWithContext(ctx context.Context) LookupTablePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LookupTablePtrOutput)
}

// LookupTableArrayInput is an input type that accepts LookupTableArray and LookupTableArrayOutput values.
// You can construct a concrete instance of `LookupTableArrayInput` via:
//
//          LookupTableArray{ LookupTableArgs{...} }
type LookupTableArrayInput interface {
	pulumi.Input

	ToLookupTableArrayOutput() LookupTableArrayOutput
	ToLookupTableArrayOutputWithContext(context.Context) LookupTableArrayOutput
}

type LookupTableArray []LookupTableInput

func (LookupTableArray) ElementType() reflect.Type {
	return reflect.TypeOf(([]*LookupTable)(nil))
}

func (i LookupTableArray) ToLookupTableArrayOutput() LookupTableArrayOutput {
	return i.ToLookupTableArrayOutputWithContext(context.Background())
}

func (i LookupTableArray) ToLookupTableArrayOutputWithContext(ctx context.Context) LookupTableArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LookupTableArrayOutput)
}

// LookupTableMapInput is an input type that accepts LookupTableMap and LookupTableMapOutput values.
// You can construct a concrete instance of `LookupTableMapInput` via:
//
//          LookupTableMap{ "key": LookupTableArgs{...} }
type LookupTableMapInput interface {
	pulumi.Input

	ToLookupTableMapOutput() LookupTableMapOutput
	ToLookupTableMapOutputWithContext(context.Context) LookupTableMapOutput
}

type LookupTableMap map[string]LookupTableInput

func (LookupTableMap) ElementType() reflect.Type {
	return reflect.TypeOf((map[string]*LookupTable)(nil))
}

func (i LookupTableMap) ToLookupTableMapOutput() LookupTableMapOutput {
	return i.ToLookupTableMapOutputWithContext(context.Background())
}

func (i LookupTableMap) ToLookupTableMapOutputWithContext(ctx context.Context) LookupTableMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LookupTableMapOutput)
}

type LookupTableOutput struct {
	*pulumi.OutputState
}

func (LookupTableOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LookupTable)(nil))
}

func (o LookupTableOutput) ToLookupTableOutput() LookupTableOutput {
	return o
}

func (o LookupTableOutput) ToLookupTableOutputWithContext(ctx context.Context) LookupTableOutput {
	return o
}

func (o LookupTableOutput) ToLookupTablePtrOutput() LookupTablePtrOutput {
	return o.ToLookupTablePtrOutputWithContext(context.Background())
}

func (o LookupTableOutput) ToLookupTablePtrOutputWithContext(ctx context.Context) LookupTablePtrOutput {
	return o.ApplyT(func(v LookupTable) *LookupTable {
		return &v
	}).(LookupTablePtrOutput)
}

type LookupTablePtrOutput struct {
	*pulumi.OutputState
}

func (LookupTablePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LookupTable)(nil))
}

func (o LookupTablePtrOutput) ToLookupTablePtrOutput() LookupTablePtrOutput {
	return o
}

func (o LookupTablePtrOutput) ToLookupTablePtrOutputWithContext(ctx context.Context) LookupTablePtrOutput {
	return o
}

type LookupTableArrayOutput struct{ *pulumi.OutputState }

func (LookupTableArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LookupTable)(nil))
}

func (o LookupTableArrayOutput) ToLookupTableArrayOutput() LookupTableArrayOutput {
	return o
}

func (o LookupTableArrayOutput) ToLookupTableArrayOutputWithContext(ctx context.Context) LookupTableArrayOutput {
	return o
}

func (o LookupTableArrayOutput) Index(i pulumi.IntInput) LookupTableOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LookupTable {
		return vs[0].([]LookupTable)[vs[1].(int)]
	}).(LookupTableOutput)
}

type LookupTableMapOutput struct{ *pulumi.OutputState }

func (LookupTableMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]LookupTable)(nil))
}

func (o LookupTableMapOutput) ToLookupTableMapOutput() LookupTableMapOutput {
	return o
}

func (o LookupTableMapOutput) ToLookupTableMapOutputWithContext(ctx context.Context) LookupTableMapOutput {
	return o
}

func (o LookupTableMapOutput) MapIndex(k pulumi.StringInput) LookupTableOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) LookupTable {
		return vs[0].(map[string]LookupTable)[vs[1].(string)]
	}).(LookupTableOutput)
}

func init() {
	pulumi.RegisterOutputType(LookupTableOutput{})
	pulumi.RegisterOutputType(LookupTablePtrOutput{})
	pulumi.RegisterOutputType(LookupTableArrayOutput{})
	pulumi.RegisterOutputType(LookupTableMapOutput{})
}
