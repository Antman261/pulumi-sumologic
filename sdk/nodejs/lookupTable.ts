// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs } from "./types";
import * as utilities from "./utilities";

/**
 * Provides a [Sumologic Lookup Table](https://help.sumologic.com/05Search/Lookup_Tables).
 *
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as sumologic from "@pulumi/sumologic";
 *
 * const lookupTable = new sumologic.LookupTable("lookupTable", {
 *     description: "some description",
 *     fields: [{
 *         fieldName: "FieldName1",
 *         fieldType: "boolean",
 *     }],
 *     parentFolderId: "<personal folder id>",
 *     primaryKeys: ["FieldName1"],
 *     sizeLimitAction: "DeleteOldData",
 *     ttl: 100,
 * });
 * ```
 * ## Argument reference
 *
 * The following arguments are supported:
 *
 * - `name` - (Required) The name of the lookup table.
 * - `parentFolderId` - (Required) The parent-folder-path identifier of the lookup table in the Library.
 * - `description` - (Required) The description of the lookup table.
 * - `fields` - (Required) The list of fields in the lookup table.
 *   - `fieldName` - (Required) The name of the field.
 *   - `fieldType` - (Required) The data type of the field. Supported types: boolean, int, long, double, string
 * - `primaryKeys` - (Required) The names of the fields that make up the primary key for the lookup table. These will be a subset of the fields that the table will contain.
 * - `ttl` - (Optional) A time to live for each entry in the lookup table (in minutes). 365 days is the maximum time to live for each entry that you can specify. Setting it to 0 means that the records will not expire automatically.
 * - `sizeLimitAction` - (Optional) The action that needs to be taken when the size limit is reached for the table. The possible values can be StopIncomingMessages or DeleteOldData. DeleteOldData will start deleting old data once size limit is reached whereas StopIncomingMessages will discard all the updates made to the lookup table once size limit is reached.
 *
 * ## Attributes reference
 *
 * The following attributes are exported:
 *
 * - `id` - Unique identifier for the partition.
 *
 * ## Import
 *
 * Lookup Tables can be imported using the id, e.g.hcl
 *
 * ```sh
 *  $ pulumi import sumologic:index/lookupTable:LookupTable test 1234567890
 * ```
 *
 *  [1]https://help.sumologic.com/05Search/Lookup_Tables
 */
export class LookupTable extends pulumi.CustomResource {
    /**
     * Get an existing LookupTable resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: LookupTableState, opts?: pulumi.CustomResourceOptions): LookupTable {
        return new LookupTable(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'sumologic:index/lookupTable:LookupTable';

    /**
     * Returns true if the given object is an instance of LookupTable.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is LookupTable {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === LookupTable.__pulumiType;
    }

    public readonly description!: pulumi.Output<string>;
    /**
     * The list of fields in the lookup table.
     */
    public readonly fields!: pulumi.Output<outputs.LookupTableField[] | undefined>;
    public readonly name!: pulumi.Output<string>;
    public readonly parentFolderId!: pulumi.Output<string | undefined>;
    /**
     * The primary key field names.
     */
    public readonly primaryKeys!: pulumi.Output<string[] | undefined>;
    public readonly sizeLimitAction!: pulumi.Output<string | undefined>;
    public readonly ttl!: pulumi.Output<number | undefined>;

    /**
     * Create a LookupTable resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: LookupTableArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: LookupTableArgs | LookupTableState, opts?: pulumi.CustomResourceOptions) {
        let inputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as LookupTableState | undefined;
            inputs["description"] = state ? state.description : undefined;
            inputs["fields"] = state ? state.fields : undefined;
            inputs["name"] = state ? state.name : undefined;
            inputs["parentFolderId"] = state ? state.parentFolderId : undefined;
            inputs["primaryKeys"] = state ? state.primaryKeys : undefined;
            inputs["sizeLimitAction"] = state ? state.sizeLimitAction : undefined;
            inputs["ttl"] = state ? state.ttl : undefined;
        } else {
            const args = argsOrState as LookupTableArgs | undefined;
            if ((!args || args.description === undefined) && !opts.urn) {
                throw new Error("Missing required property 'description'");
            }
            inputs["description"] = args ? args.description : undefined;
            inputs["fields"] = args ? args.fields : undefined;
            inputs["name"] = args ? args.name : undefined;
            inputs["parentFolderId"] = args ? args.parentFolderId : undefined;
            inputs["primaryKeys"] = args ? args.primaryKeys : undefined;
            inputs["sizeLimitAction"] = args ? args.sizeLimitAction : undefined;
            inputs["ttl"] = args ? args.ttl : undefined;
        }
        if (!opts.version) {
            opts = pulumi.mergeOptions(opts, { version: utilities.getVersion()});
        }
        super(LookupTable.__pulumiType, name, inputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering LookupTable resources.
 */
export interface LookupTableState {
    readonly description?: pulumi.Input<string>;
    /**
     * The list of fields in the lookup table.
     */
    readonly fields?: pulumi.Input<pulumi.Input<inputs.LookupTableField>[]>;
    readonly name?: pulumi.Input<string>;
    readonly parentFolderId?: pulumi.Input<string>;
    /**
     * The primary key field names.
     */
    readonly primaryKeys?: pulumi.Input<pulumi.Input<string>[]>;
    readonly sizeLimitAction?: pulumi.Input<string>;
    readonly ttl?: pulumi.Input<number>;
}

/**
 * The set of arguments for constructing a LookupTable resource.
 */
export interface LookupTableArgs {
    readonly description: pulumi.Input<string>;
    /**
     * The list of fields in the lookup table.
     */
    readonly fields?: pulumi.Input<pulumi.Input<inputs.LookupTableField>[]>;
    readonly name?: pulumi.Input<string>;
    readonly parentFolderId?: pulumi.Input<string>;
    /**
     * The primary key field names.
     */
    readonly primaryKeys?: pulumi.Input<pulumi.Input<string>[]>;
    readonly sizeLimitAction?: pulumi.Input<string>;
    readonly ttl?: pulumi.Input<number>;
}
